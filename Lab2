%%cu
#include <stdlib.h>
#include <stdio.h>
#include <ctime>

#define N 20
#define t 15

void ChangeArraySize(long int *n){
    long int k = *n;
    if (k % 2 == 0){
        *n /= 2;
    }
    else{
        *n = (*n + 1) / 2;
    }
}

__global__ void ExtractHigh(long int *aDev, long int *aHighDev, long int *n){
    long int idx = threadIdx.x + blockIdx.x * blockDim.x;
    long int k = *n;
    if (k % 2 == 0){
        if (idx < k / 2){
            aHighDev[idx] = aDev[k - idx - 1];
        }
    }
    else {
        if (idx < (k + 1) / 2){
            if (idx == (k - 1) / 2){
                aHighDev[idx] = 1;
            }
            else{
                aHighDev[idx] = aDev[k - idx - 1];
            }
        }
    }
    
}

__global__ void ExtractLow(long int *aDev, long int *aLowDev, long int *n){
    long int idx = threadIdx.x + blockIdx.x * blockDim.x;
    long int k = *n;
    if (k % 2 == 0){
        if (idx < k / 2){
            aLowDev[idx] = aDev[idx];
        }
    }
    else {
        if (idx < (k + 1) / 2){
            aLowDev[idx] = aDev[idx];
        }
    }
    
}

__global__ void Mul(long int *a, long int *b, long int *c, long int *n) {
    long int idx = threadIdx.x + blockIdx.x * blockDim.x;
    long int k = *n;
    if (k % 2 == 0){
        if (idx < k / 2){
        c[idx] = a[idx] * b[idx];
    }
    }
    else{
        if (idx < (k + 1)/ 2){
        c[idx] = a[idx] * b[idx];
    }
    }
    
}

long int Fract(long int n){
    long int res = 1;
    if (n == 0){
        return 1;
    }
    for (long int i = 1; i <= n; i++){
        res *= i;
    }
    return res;
}

int main(){
    long int p = 0, q =0, l = 0;
    int start = 0, finish = 0, GPU_time = 0, CPU_time = 0;
    long int *fract_array, *array_size;
    long int *aDev = NULL, *aHighDev = NULL, *aLowDev = NULL;
    long int *n = NULL;
    dim3 threads, blocks;
    start = clock();
    if (N == 0){
    p = 1;
    }
    else{
    fract_array = (long int *) malloc(N * sizeof(long int));
    array_size = (long int *) malloc(sizeof(long int));
    *array_size = N;

    for (long int i = 0; i < *array_size; i++){
        fract_array[i] = i + 1;
    }

    cudaMalloc((void **) &aDev, *array_size * sizeof(long int));
    cudaMalloc((void **) &n, sizeof(long int));
    cudaMalloc((void **) &aHighDev, *array_size / 2 * sizeof(long int));
    cudaMalloc((void **) &aLowDev, *array_size / 2 * sizeof(long int));

    
    dim3 threads = dim3(N, 1);
    dim3 blocks = dim3(N / threads.x, 1);

    cudaMemcpy(aDev, fract_array, *array_size * sizeof(long int), cudaMemcpyHostToDevice);
    cudaMemcpy(n, array_size, sizeof(long int), cudaMemcpyHostToDevice);  

    while (*array_size > 1){    
           
        ExtractHigh<<<blocks, threads>>> (aDev, aHighDev, n);
        cudaDeviceSynchronize();
        ExtractLow<<<blocks, threads>>> (aDev, aLowDev, n);
        cudaDeviceSynchronize();
        Mul<<<blocks, threads>>> (aHighDev, aLowDev, aDev, n);
        cudaDeviceSynchronize();
        ChangeArraySize(array_size);
        
        
        cudaMemcpy(n, array_size, sizeof(long int), cudaMemcpyHostToDevice);
        cudaDeviceSynchronize();
    } 

    cudaMemcpy(fract_array, aDev, *array_size * sizeof(long int), cudaMemcpyDeviceToHost);
    
    p = fract_array[0];

    cudaFree(aDev);
    cudaFree(aHighDev);
    cudaFree(aLowDev);
    cudaFree(n);
    free(fract_array);
    free(array_size);
    }

    if(t == 0){
    q = 1;
    }
    else{
    fract_array = (long int *) malloc(N * sizeof(long int));
    array_size = (long int *) malloc(sizeof(long int));
    *array_size = t;

    for (long int i = 0; i < *array_size; i++){
        fract_array[i] = i + 1;
    }


    cudaMalloc((void **) &aDev, *array_size * sizeof(long int));
    cudaMalloc((void **) &n, sizeof(long int));
    cudaMalloc((void **) &aHighDev, *array_size / 2 * sizeof(long int));
    cudaMalloc((void **) &aLowDev, *array_size / 2 * sizeof(long int));

    
    threads = dim3(t, 1);
    blocks = dim3(t / threads.x, 1);

    cudaMemcpy(aDev, fract_array, *array_size * sizeof(long int), cudaMemcpyHostToDevice);
    cudaMemcpy(n, array_size, sizeof(long int), cudaMemcpyHostToDevice);  

    while (*array_size > 1){    
           
        ExtractHigh<<<blocks, threads>>> (aDev, aHighDev, n);
        cudaDeviceSynchronize();
        ExtractLow<<<blocks, threads>>> (aDev, aLowDev, n);
        cudaDeviceSynchronize();
        Mul<<<blocks, threads>>> (aHighDev, aLowDev, aDev, n);
        cudaDeviceSynchronize();
        ChangeArraySize(array_size);
        
        
        cudaMemcpy(n, array_size, sizeof(long int), cudaMemcpyHostToDevice);
        cudaDeviceSynchronize();
    } 

    cudaMemcpy(fract_array, aDev, *array_size * sizeof(long int), cudaMemcpyDeviceToHost);
    
    q = fract_array[0];
    cudaFree(aDev);
    cudaFree(aHighDev);
    cudaFree(aLowDev);
    cudaFree(n);
    free(fract_array);
    free(array_size);
    }

    if((N-t) == 0){
    l = 1;
    }
    else{
    fract_array = (long int *) malloc(N * sizeof(long int));
    array_size = (long int *) malloc(sizeof(long int));
    *array_size = N - t;

    for (long int i = 0; i < *array_size; i++){
        fract_array[i] = i + 1;
    }


    cudaMalloc((void **) &aDev, *array_size * sizeof(long int));
    cudaMalloc((void **) &n, sizeof(long int));
    cudaMalloc((void **) &aHighDev, *array_size / 2 * sizeof(long int));
    cudaMalloc((void **) &aLowDev, *array_size / 2 * sizeof(long int));

    
    threads = dim3(N - t, 1);
    blocks = dim3((N - t) / threads.x, 1);

    cudaMemcpy(aDev, fract_array, *array_size * sizeof(long int), cudaMemcpyHostToDevice);
    cudaMemcpy(n, array_size, sizeof(long int), cudaMemcpyHostToDevice);  

    while (*array_size > 1){    
           
        ExtractHigh<<<blocks, threads>>> (aDev, aHighDev, n);
        cudaDeviceSynchronize();
        ExtractLow<<<blocks, threads>>> (aDev, aLowDev, n);
        cudaDeviceSynchronize();
        Mul<<<blocks, threads>>> (aHighDev, aLowDev, aDev, n);
        cudaDeviceSynchronize();
        ChangeArraySize(array_size);
        
        
        cudaMemcpy(n, array_size, sizeof(long int), cudaMemcpyHostToDevice);
        cudaDeviceSynchronize();
    } 

    cudaMemcpy(fract_array, aDev, *array_size * sizeof(long int), cudaMemcpyDeviceToHost);
    
    l = fract_array[0];
    cudaFree(aDev);
    cudaFree(aHighDev);
    cudaFree(aLowDev);
    cudaFree(n);
    free(fract_array);
    free(array_size);
    }

    long int C = p / (q * l);

    finish = clock();
    GPU_time = (finish - start)/100;
    printf("number of combinations from %ld to %ld: %ld\n", N, t, C);
    printf("GPU time: %i\n", GPU_time);

    start = clock();
    long int g1 = N, g2 = t, g3 = N-t;
    g1 = Fract(g1);
    g2 = Fract(g2);
    g3 = Fract(g3);
    C = g1/ (g2 *g3);
    printf("number of combinations from %ld to %ld: %ld\n", N, t, C);
    finish = clock();
    CPU_time = (finish - start)*1000; 
    printf("CPU time: %i\n", CPU_time);

}
